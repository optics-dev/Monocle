<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Lens · Monocle</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="A `Lens` is an optic used to zoom inside a `Product`, e.g. `case class`, `Tuple`, `HList` or even `Map`."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Lens · Monocle"/><meta property="og:type" content="website"/><meta property="og:url" content="https://optics.dev/Monocle/Monocle/"/><meta property="og:description" content="A `Lens` is an optic used to zoom inside a `Product`, e.g. `case class`, `Tuple`, `HList` or even `Map`."/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/Monocle/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css"/><script src="/Monocle/js/scrollSpy.js"></script><link rel="stylesheet" href="/Monocle/css/main.css"/><script src="/Monocle/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/Monocle/"><img class="logo" src="/Monocle/img/monocle-full-white.png" alt="Monocle"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/Monocle/api/monocle/index.html" target="_self">API Docs</a></li><li class="siteNavGroupActive"><a href="/Monocle/docs/optics" target="_self">Optics</a></li><li class="siteNavGroupActive"><a href="/Monocle/docs/release_notes" target="_self">Release Notes</a></li><li class="siteNavGroupActive"><a href="/Monocle/docs/faq" target="_self">FAQ</a></li><li class=""><a href="https://github.com/optics-dev/monocle" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Optics</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Optics</h3><ul class=""><li class="navListItem"><a class="navItem" href="/Monocle/docs/optics">Optics</a></li><li class="navListItem"><a class="navItem" href="/Monocle/docs/optics/iso">Iso</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/Monocle/docs/optics/lens">Lens</a></li><li class="navListItem"><a class="navItem" href="/Monocle/docs/optics/prism">Prism</a></li><li class="navListItem"><a class="navItem" href="/Monocle/docs/optics/optional">Optional</a></li><li class="navListItem"><a class="navItem" href="/Monocle/docs/optics/traversal">Traversal</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Documentation</h3><ul class=""><li class="navListItem"><a class="navItem" href="/Monocle/docs/modules">Modules</a></li><li class="navListItem"><a class="navItem" href="/Monocle/docs/examples">Examples</a></li><li class="navListItem"><a class="navItem" href="/Monocle/docs/faq">FAQ</a></li><li class="navListItem"><a class="navItem" href="/Monocle/docs/release_notes">Release Notes</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Lens</h1></header><article><div><span><p>A <code>Lens</code> is an optic used to zoom inside a <code>Product</code>, e.g. <code>case class</code>, <code>Tuple</code>, <code>HList</code> or even <code>Map</code>.</p>
<p><code>Lenses</code> have two type parameters generally called <code>S</code> and <code>A</code>: <code>Lens[S, A]</code> where <code>S</code> represents the <code>Product</code> and <code>A</code> an element inside of <code>S</code>.</p>
<p>Let's take a simple case class with two fields:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span>(<span class="hljs-params">streetNumber: <span class="hljs-type">Int</span>, streetName: <span class="hljs-type">String</span></span>)</span>
</code></pre>
<p>We can create a <code>Lens[Address, Int]</code> which zooms from an <code>Address</code> to its field <code>streetNumber</code> by supplying a pair of functions:</p>
<ul>
<li><code>get: Address =&gt; Int</code></li>
<li><code>set: Int =&gt; Address =&gt; Address</code></li>
</ul>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monocle.<span class="hljs-type">Lens</span>
<span class="hljs-keyword">val</span> streetNumber = <span class="hljs-type">Lens</span>[<span class="hljs-type">Address</span>, <span class="hljs-type">Int</span>](_.streetNumber)(n =&gt; a =&gt; a.copy(streetNumber = n))
</code></pre>
<p>This case is really straightforward so we automated the generation of <code>Lenses</code> from case classes using a macro:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monocle.macros.<span class="hljs-type">GenLens</span>
<span class="hljs-keyword">val</span> streetNumber = <span class="hljs-type">GenLens</span>[<span class="hljs-type">Address</span>](_.streetNumber)
</code></pre>
<p>Once we have a <code>Lens</code>, we can use the supplied <code>get</code> and <code>set</code> functions (nothing fancy!):</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> address = <span class="hljs-type">Address</span>(<span class="hljs-number">10</span>, <span class="hljs-string">"High Street"</span>)
<span class="hljs-comment">// address: Address = Address(streetNumber = 10, streetName = "High Street")</span>

streetNumber.get(address)
<span class="hljs-comment">// res0: Int = 10</span>
streetNumber.set(<span class="hljs-number">5</span>)(address)
<span class="hljs-comment">// res1: Address = Address(streetNumber = 5, streetName = "High Street")</span>
</code></pre>
<p>We can also <code>modify</code> the target of <code>Lens</code> with a function, this is equivalent to call <code>get</code> and then <code>set</code>:</p>
<pre><code class="hljs css language-scala">streetNumber.modify(_ + <span class="hljs-number">1</span>)(address)
<span class="hljs-comment">// res2: Address = Address(streetNumber = 11, streetName = "High Street")</span>

<span class="hljs-keyword">val</span> n = streetNumber.get(address)
<span class="hljs-comment">// n: Int = 10</span>
streetNumber.set(n + <span class="hljs-number">1</span>)(address)
<span class="hljs-comment">// res3: Address = Address(streetNumber = 11, streetName = "High Street")</span>
</code></pre>
<p>We can push the idea even further, with <code>modifyF</code> we can update the target of a <code>Lens</code> in a context, cf <code>cats.Functor</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">neighbors</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] =
  <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">0</span>) <span class="hljs-type">List</span>(n - <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>) <span class="hljs-keyword">else</span> <span class="hljs-type">List</span>(n + <span class="hljs-number">1</span>)

<span class="hljs-keyword">import</span> cats.implicits._ <span class="hljs-comment">// to get all Functor instance</span>
</code></pre>
<pre><code class="hljs css language-scala">streetNumber.modifyF(neighbors)(address)
<span class="hljs-comment">// res4: List[Address] = List(</span>
<span class="hljs-comment">//   Address(streetNumber = 9, streetName = "High Street"),</span>
<span class="hljs-comment">//   Address(streetNumber = 11, streetName = "High Street")</span>
<span class="hljs-comment">// )</span>
streetNumber.modifyF(neighbors)(<span class="hljs-type">Address</span>(<span class="hljs-number">135</span>, <span class="hljs-string">"High Street"</span>))
<span class="hljs-comment">// res5: List[Address] = List(</span>
<span class="hljs-comment">//   Address(streetNumber = 134, streetName = "High Street"),</span>
<span class="hljs-comment">//   Address(streetNumber = 136, streetName = "High Street")</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>This would work with any kind of <code>Functor</code> and is especially useful in conjunction with asynchronous APIs,
where one has the task to update a deeply nested structure with the result of an asynchronous computation:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> scala.concurrent._
<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">ExecutionContext</span>.<span class="hljs-type">Implicits</span>._ <span class="hljs-comment">// to get global ExecutionContext</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">updateNumber</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Future</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Future</span>.successful(n + <span class="hljs-number">1</span>)
</code></pre>
<pre><code class="hljs css language-scala">streetNumber.modifyF(updateNumber)(address)
<span class="hljs-comment">// res6: Future[Address] = Future(Success(Address(11,High Street)))</span>
</code></pre>
<p>Most importantly, <code>Lenses</code> compose together allowing to zoom deeper in a data structure</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span>, address: <span class="hljs-type">Address</span></span>)</span>
<span class="hljs-keyword">val</span> john = <span class="hljs-type">Person</span>(<span class="hljs-string">"John"</span>, <span class="hljs-number">20</span>, <span class="hljs-type">Address</span>(<span class="hljs-number">10</span>, <span class="hljs-string">"High Street"</span>))

<span class="hljs-keyword">val</span> address = <span class="hljs-type">GenLens</span>[<span class="hljs-type">Person</span>](_.address)
</code></pre>
<pre><code class="hljs css language-scala">address.andThen(streetNumber).get(john)
<span class="hljs-comment">// res7: Int = 10</span>
address.andThen(streetNumber).set(<span class="hljs-number">2</span>)(john)
<span class="hljs-comment">// res8: Person = Person(</span>
<span class="hljs-comment">//   name = "John",</span>
<span class="hljs-comment">//   age = 20,</span>
<span class="hljs-comment">//   address = Address(streetNumber = 2, streetName = "High Street")</span>
<span class="hljs-comment">// )</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="other-ways-of-lens-composition"></a><a href="#other-ways-of-lens-composition" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Other Ways of Lens Composition</h2>
<p>Is possible to compose few <code>Lenses</code> together by using <code>compose</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">GenLens</span>[<span class="hljs-type">Person</span>](_.name).set(<span class="hljs-string">"Mike"</span>) compose <span class="hljs-type">GenLens</span>[<span class="hljs-type">Person</span>](_.age).modify(_ + <span class="hljs-number">1</span>)
</code></pre>
<p>Same but with the simplified macro based syntax:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monocle.macros.syntax.lens._

john.lens(_.name).set(<span class="hljs-string">"Mike"</span>).lens(_.age).modify(_ + <span class="hljs-number">1</span>)
</code></pre>
<p>(All <code>Setter</code> like optics offer <code>set</code> and <code>modify</code> methods that returns an <code>EndoFunction</code> (i.e. <code>S =&gt; S</code>) which means that we can compose modification using basic function composition.)</p>
<p>Sometimes you need an easy way to update <code>Product</code> type inside
<code>Sum</code> type - for that case you can compose <code>Prism</code> with <code>Lens</code> by using <code>some</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monocle.macros.<span class="hljs-type">GenLens</span>

<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-params">c: <span class="hljs-type">Int</span></span>)</span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params">b: <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>]</span>)</span>

<span class="hljs-keyword">val</span> c = <span class="hljs-type">GenLens</span>[<span class="hljs-type">B</span>](_.c)
<span class="hljs-comment">// c: Lens[B, Int] = repl.MdocSession$App$$anon$7@6bb090dc</span>
<span class="hljs-keyword">val</span> b = <span class="hljs-type">GenLens</span>[<span class="hljs-type">A</span>](_.b)
<span class="hljs-comment">// b: Lens[A, Option[B]] = repl.MdocSession$App$$anon$8@33bfec7f</span>

b.some.andThen(c).getOption(<span class="hljs-type">A</span>(<span class="hljs-type">Some</span>(<span class="hljs-type">B</span>(<span class="hljs-number">1</span>))))
<span class="hljs-comment">// res11: Option[Int] = Some(value = 1)</span>
</code></pre>
<p>For more detailed view of the various optics composition see <a href="../optics.html">Optics</a></p>
<h2><a class="anchor" aria-hidden="true" id="lens-generation"></a><a href="#lens-generation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lens Generation</h2>
<p><code>Lens</code> creation is rather boiler platy but we developed a few macros to generate them automatically. All macros
are defined in a separate module (see <a href="../modules.html">modules</a>).</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monocle.macros.<span class="hljs-type">GenLens</span>
<span class="hljs-keyword">val</span> age = <span class="hljs-type">GenLens</span>[<span class="hljs-type">Person</span>](_.age)
</code></pre>
<p><code>GenLens</code> can also be used to generate <code>Lens</code> several level deep:</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">GenLens</span>[<span class="hljs-type">Person</span>](_.address.streetName).set(<span class="hljs-string">"Iffley Road"</span>)(john)
<span class="hljs-comment">// res12: Person = Person(</span>
<span class="hljs-comment">//   name = "John",</span>
<span class="hljs-comment">//   age = 20,</span>
<span class="hljs-comment">//   address = Address(streetNumber = 10, streetName = "Iffley Road")</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>For those who want to push <code>Lenses</code> generation even further, we created <code>@Lenses</code> macro annotation which generate
<code>Lenses</code> for <em>all</em> fields of a case class. The generated <code>Lenses</code> are in the companion object of the case class:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monocle.macros.<span class="hljs-type">Lenses</span>
<span class="hljs-meta">@Lenses</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>(<span class="hljs-params">x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span></span>)</span>
<span class="hljs-keyword">val</span> p = <span class="hljs-type">Point</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)
</code></pre>
<pre><code class="hljs css language-scala"><span class="hljs-type">Point</span>.x.get(p)
<span class="hljs-comment">// res13: Int = 5</span>
<span class="hljs-type">Point</span>.y.set(<span class="hljs-number">0</span>)(p)
<span class="hljs-comment">// res14: Point = Point(x = 5, y = 0)</span>
</code></pre>
<p>You can also add a prefix to <code>@Lenses</code> in order to prefix the generated <code>Lenses</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-meta">@Lenses</span>(<span class="hljs-string">"_"</span>) <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrefixedPoint</span>(<span class="hljs-params">x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span></span>)</span>
<span class="hljs-keyword">val</span> p = <span class="hljs-type">PrefixedPoint</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)
</code></pre>
<pre><code class="hljs css language-scala"><span class="hljs-type">PrefixedPoint</span>._x.get(p)
<span class="hljs-comment">// res15: Int = 5</span>
</code></pre>
<p>Note: before using <code>@Lenses</code> remember to activate macro annotations. See <a href="../../#getting-started">Getting started</a> section for instructions.</p>
<h2><a class="anchor" aria-hidden="true" id="laws"></a><a href="#laws" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Laws</h2>
<p>A <code>Lens</code> must satisfy all properties defined in <code>LensLaws</code> from the <code>core</code> module.
You can check the validity of your own <code>Lenses</code> using <code>LensTests</code> from the <code>law</code> module.</p>
<p>In particular, a <code>Lens</code> must respect the <code>getSet</code> law which states that if you <code>get</code> a value <code>A</code> from <code>S</code> and
<code>set</code> it back in, the result is an object identical to the original one. A side effect of this law is that <code>set</code>
must only update the <code>A</code> it points to, for example it cannot increment a counter or modify another value.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getSet</span></span>[<span class="hljs-type">S</span>, <span class="hljs-type">A</span>](l: <span class="hljs-type">Lens</span>[<span class="hljs-type">S</span>, <span class="hljs-type">A</span>], s: <span class="hljs-type">S</span>): <span class="hljs-type">Boolean</span> =
  l.set(l.get(s))(s) == s
</code></pre>
<p>On the other hand, the <code>setGet</code> law states that if you <code>set</code> a value, you always <code>get</code> the same value back.
This law guarantees that <code>set</code> is actually updating a value <code>A</code> inside of <code>S</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setGet</span></span>[<span class="hljs-type">S</span>, <span class="hljs-type">A</span>](l: <span class="hljs-type">Lens</span>[<span class="hljs-type">S</span>, <span class="hljs-type">A</span>], s: <span class="hljs-type">S</span>, a: <span class="hljs-type">A</span>): <span class="hljs-type">Boolean</span> =
  l.get(l.set(a)(s)) == a
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/Monocle/docs/optics/iso"><span class="arrow-prev">← </span><span>Iso</span></a><a class="docs-next button" href="/Monocle/docs/optics/prism"><span>Prism</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#other-ways-of-lens-composition">Other Ways of Lens Composition</a></li><li><a href="#lens-generation">Lens Generation</a></li><li><a href="#laws">Laws</a></li></ul></nav></div><footer class="nav-footer" id="footer"><hr class="separator"/><section class="copyright">Copyright the maintainers © 2016-2020.</section></footer></div></body></html>